/**
 *
 *  ******************************************************************************
 *  MontiCAR Modeling Family, www.se-rwth.de
 *  Copyright (c) 2017, Software Engineering Group at RWTH Aachen,
 *  All rights reserved.
 *
 *  This project is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3.0 of the License, or (at your option) any later version.
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this project. If not, see <http://www.gnu.org/licenses/>.
 * *******************************************************************************
 */
/* generated from model null*/
/* generated by template symboltable.SymbolTableCreator*/




package de.monticore.lang.monticar.stream._symboltable;

import java.util.ArrayList;
import java.util.Optional;

import de.monticore.lang.monticar.stream._ast.ASTComponentStream;
import de.monticore.lang.monticar.stream._ast.ASTNamedStream;
import de.monticore.lang.monticar.stream._ast.ASTStreamCompilationUnit;
import de.monticore.literals.literals._ast.*;
import de.monticore.symboltable.ArtifactScope;
import de.monticore.symboltable.MutableScope;
import de.monticore.symboltable.ResolvingConfiguration;
import de.se_rwth.commons.Names;
import de.se_rwth.commons.logging.Log;

public class StreamSymbolTableCreator extends StreamSymbolTableCreatorTOP {

  private static int id = 0;

  public StreamSymbolTableCreator(
    final ResolvingConfiguration resolvingConfig, final MutableScope enclosingScope) {
    super(resolvingConfig, enclosingScope);
  }

  @Override
  public void visit(ASTStreamCompilationUnit node) {
    Log.debug("Building Symboltable for Stream: " + node.getComponentStream().getName(),
        StreamSymbolTableCreator.class.getSimpleName());
    String compilationUnitPackage = Names.getQualifiedName(node.getPackage());
    ArtifactScope artifactScope = new ArtifactScope(
        Optional.empty(),
        compilationUnitPackage,
        new ArrayList<>());
    putOnStack(artifactScope);
    id++;
  }

  @Override
  public void endVisit(ASTStreamCompilationUnit node) {
    removeCurrentScope();
  }

  @Override
  public void visit(ASTComponentStream node) {
    ComponentStreamSymbol streamSymbol = new ComponentStreamSymbol(node.getName());
    addToScopeAndLinkWithNode(streamSymbol, node);
  }

  @Override
  public void endVisit(ASTComponentStream node) {
    removeCurrentScope();
  }

  @Override
  public void visit(ASTNamedStream node) {
    NamedStreamSymbol streamSymbol = new NamedStreamSymbol(node.getName(), id);
    for (ASTSignedLiteral num : node.getStream().getSignedLiterals()) {
      if (num instanceof ASTSignedDoubleLiteral) {
        if (((ASTSignedDoubleLiteral) num).isNegative()) {
          streamSymbol.add(Double.parseDouble("-" + ((ASTSignedDoubleLiteral) num).getSource()));
        } else {
          streamSymbol.add(Double.parseDouble(((ASTSignedDoubleLiteral) num).getSource()));
        }
      } else if (num instanceof ASTDoubleLiteral)
        streamSymbol.add(Double.parseDouble(((ASTDoubleLiteral)num).getSource()));
      else if (num instanceof ASTSignedIntLiteral) {
        if (((ASTSignedIntLiteral) num).isNegative()) {
          streamSymbol.add(Integer.parseInt("-" + ((ASTSignedIntLiteral) num).getSource()));
        } else {
          streamSymbol.add(Integer.parseInt(((ASTSignedIntLiteral) num).getSource()));
        }
      } else if (num instanceof ASTIntLiteral)
        streamSymbol.add(Integer.parseInt(((ASTIntLiteral)num).getSource()));
    }
    addToScopeAndLinkWithNode(streamSymbol, node);
  }
}
