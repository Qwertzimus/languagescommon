/**
 *
 *  ******************************************************************************
 *  MontiCAR Modeling Family, www.se-rwth.de
 *  Copyright (c) 2017, Software Engineering Group at RWTH Aachen,
 *  All rights reserved.
 *
 *  This project is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3.0 of the License, or (at your option) any later version.
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this project. If not, see <http://www.gnu.org/licenses/>.
 * *******************************************************************************
 */
/* generated from model null*/
/* generated by template symboltable.SymbolTableCreator*/


package de.monticore.lang.monticar.streamunits._symboltable;

import de.monticore.lang.monticar.literals2._ast.ASTSignedLiteral;
import de.monticore.lang.monticar.streamunits._ast.*;
import de.monticore.symboltable.ArtifactScope;
import de.monticore.symboltable.MutableScope;
import de.monticore.symboltable.ResolvingConfiguration;
import de.se_rwth.commons.Names;
import de.se_rwth.commons.logging.Log;

import java.util.ArrayList;
import java.util.Optional;

import de.monticore.lang.numberunit._ast.*;

public class StreamUnitsSymbolTableCreator extends StreamUnitsSymbolTableCreatorTOP {

    private static int id = 0;

    public StreamUnitsSymbolTableCreator(
            final ResolvingConfiguration resolvingConfig, final MutableScope enclosingScope) {
        super(resolvingConfig, enclosingScope);
    }

    @Override
    public void visit(ASTStreamUnitsCompilationUnit node) {
        Log.debug("Building Symboltable for Stream: " + node.getComponentStreamUnits().getName(),
                StreamUnitsSymbolTableCreator.class.getSimpleName());
        String compilationUnitPackage = Names.getQualifiedName(node.getPackage());
        ArtifactScope artifactScope = new ArtifactScope(
                Optional.empty(),
                compilationUnitPackage,
                new ArrayList<>());
        putOnStack(artifactScope);
        id++;
    }

    @Override
    public void endVisit(ASTStreamUnitsCompilationUnit node) {
        removeCurrentScope();
    }

    @Override
    public void visit(ASTComponentStreamUnits node) {
        ComponentStreamUnitsSymbol streamSymbol = new ComponentStreamUnitsSymbol(node.getName());
        addToScopeAndLinkWithNode(streamSymbol, node);
    }

    @Override
    public void endVisit(ASTComponentStreamUnits node) {
        removeCurrentScope();
    }

    @Override
    public void visit(ASTNamedStreamUnits node) {
        NamedStreamUnitsSymbol streamSymbol = new NamedStreamUnitsSymbol(node.getName(), id);
        for (ASTStreamInstruction streamInstruction : node.getStream().getStreamInstructions()) {
            if (streamInstruction.getStreamValue().isPresent()) {
                ASTStreamValue streamValue = streamInstruction.getStreamValue().get();
                if (streamValue.getPrecisionNumber().isPresent()) {
                    ASTPrecisionNumber num = streamValue.getPrecisionNumber().get();
                    if (num.getPrecision().isPresent()) {
                        streamSymbol.add(num.getUnitNumber(), num.getPrecision().get().getUnitNumber());
                    } else {
                        streamSymbol.add(new StreamValuePrecision(num.getUnitNumber()));
                    }

                } else if (streamValue.getName().isPresent()) {
                    streamSymbol.add(new StreamValuePrecision(streamValue.getName().get()));
                } else if (streamValue.getSignedLiteral().isPresent()) {
                    ASTSignedLiteral signedLiteral = streamInstruction.getStreamValue().get().getSignedLiteral().get();
                    streamSymbol.add(new StreamValuePrecision(signedLiteral));
                } else if (streamValue.getDontCare().isPresent()) {
                    streamSymbol.add(new StreamValuePrecision("-"));
                }else if(streamValue.getValueAtTick().isPresent()){
                    ASTValueAtTick valueAtTick=streamValue.getValueAtTick().get();
                    streamSymbol.add(new StreamValueAtTick(valueAtTick));
                }
            } else if (streamInstruction.getStreamCompare().isPresent()) {
                ASTStreamCompare astStreamCompare = streamInstruction.getStreamCompare().get();
                streamSymbol.add(new StreamCompare(new StreamValuePrecision(astStreamCompare.getLeft()),
                        astStreamCompare.getOperator(), new StreamValuePrecision(astStreamCompare.getRight())));
            }


        }
        addToScopeAndLinkWithNode(streamSymbol, node);
    }
}
